import numpy as np
import cv2

# Загружаем «классификатор
faceCascade = cv2.CascadeClassifier('Cascades/haarcascade_frontalface_alt.xml')

# Создаем экземпляр класса VideoCapture(). Принимает один аргумент - это
# путь к файлу (относительный или абсолютный) или целое число (индекс
# подключенной камеры)
cap = cv2.VideoCapture(0)

cap.set(3, 640) # set Width
cap.set(4, 480) # set Height

while True:
    # Функция cap.read() класса VideoCapture() возвращает два объекта:
    # 1) булевое значение (True или False), в случае отсутствия ошибок при
    # загрузке текущего кадра - True. Запишем это в переменную ret
    # 2) сам текущий прочитанный кадр из видео. Запишем его в переменную frame.
    ret, img = cap.read()

    #img = cv2.flip(img, -1) # Flip camera vertically

    # Функция cvtColor() конвертирует изображение в нужное цветовое
    # представление. Принимает аргументами сам объект изображения и имя
    # представления, в нашем случае - это черно-белое для уменьшения
    # ресурсозатрат при выводе прочитанного видео на экран.
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Классификаторная функция
    faces = faceCascade.detectMultiScale(
        gray,                 # это входное изображение в оттенках серого
        scaleFactor = 1.2,    # масштабный коэффициент (размер изображения при каждой шкале изображения. Он используется для создания масштабной пирамиды.)
        minNeighbors = 5,     # количество соседей (сколько соседей должно иметь каждый прямоугольник кандидата, чтобы сохранить его. Более высокое число дает более низкие ложные срабатывания)
        minSize = (20, 20)    # минимальный размер обнаруженного лица (прямоугольника, который считается лицом)
    )

    # «Маркировать» лица на изображении, используя, например, синий прямоугольник
    # Если грани найдены, они возвращают позиции обнаруженных лиц в виде
    # прямоугольника с левым углом (x, y) и имеют «w» в качестве его ширины
    # и «h» как его высоту ==> (x, y, w, h)
    for (x,y,w,h) in faces:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

        # Как только мы получим эти координаты, можем создать «ROI»
        # (рисованный прямоугольник) для лица
        roi_gray = gray[y: y + h, x: x + w]
        roi_color = img[y: y + h, x: x + w]

    # Вывести единичное изображение (объект Open CV) на экран в отдельном окне.
    cv2.imshow('video', img)

    # 0xFF - это шестнадцатеричная константа, которая является 11111111 в
    # двоичном формате. Используя побитовое И (&) с этой константой, он
    # оставляет только последние 8 бит оригинала (в этом случае, независимо
    # от cv2.waitKey(0)).
    k = cv2.waitKey(30) & 0xff

    # press 'ESC' to quit
    if k == 27:
        break

# Освобождаем оперативную память, занятую переменной cap
cap.release()

# Закрываем все открытые в скрипте окна
cv2.destroyAllWindows()